# 28. 초록 막대 패턴
실패하는 테스트가 있다면 고쳐야 한다. 그리고 빨간 막대를 가능한 빨리 통과시키기 위해 다음의 패턴들을 사용하면 된다.

## 가짜로 구현하기(진짜로 만들기 전까지만)
실패하는 테스트를 만든 후 첫 번째 구현은 어떻게 하는 게 좋을까? 상수를 반환하게 하라.  
일단 테스트가 통과하면 단계적으로 상수를 변수를 사용하는 수식으로 변형한다.  
가짜로 구현하기를 강력하게 만드는 두 가지 효과가 있다.
 - 심리학적: 빨간 막대와 초록 막대 상태는 완전히 다르다. 막대가 초록색이라면 어느 위치인지 알고 거기부터 리팩토링해 갈 수 있다.
 - 범위 조절:하나의 구체적인 예에서 시작해서 일반화하게 되면, 쓰잘데기 없는 고민으로 때 이르게 혼동하는 일을 예방할 수 있다.

필요 없는 코드는 조금도 작성하지 말라는 법칙에 가짜로 구현하기가 위배되는가?  
그렇지 않다. 리팩토링 단계에서 테스트 케이스와 코드 간의 데이터 중복을 제거하기 때문이다.

## 삼각측량
추상화 과정을 테스트로 주도할 때 최대한 보수적으로 하기 위해서는 오로지 예가 2개 이상일 때에만 추상화를 해야 한다.  
예를 들어 두 정수의 합을 반환하는 함수를 작성하고 싶다고 가정하자. 다음과 같이 작성한다.
```JAVA
public void testSum() {
    assertEquals(4, plus(3, 1));
}

private int plus(int augend, int addend) {
    return 4;
}

```
삼각측량을 사용해서 바른 설계로 간다면 다음과 같이 작성해야 한다.

```JAVA
public void testSum() {
    assertEquals(4, plus(3, 1));
    assertEquals(7, plus(3, 4));
}
```
두번째 예를 얻었을 때 plus()의 구현을 추상화 할수 있다.
```JAVA
private int plus(int augend, int addend) {
    return augend + addend;
}
```
삼각 측량이 매력적인 이유는 그 규칙이 매우 명확하기 때문이다.  
켄트 백은 어떤 계산을 어떻게 해야 올바르게 추상화할 것인지에 대해 정말 감잡기 어려울 때만 삼각측량을 사용한다고 한다.  
그 외의 경우, 명백한 구현이나 가짜로 구현하기에 의존한다.

## 명백한 구현
단순한 연산들은 어떻게 구현하는가? 그냥 구현해 버려라  
가짜로 구현하기와 삼각측량은 눈곱만큼 작은 발걸음이다. 만약 빨간 막대를 보고 놀란다면 그제서야 좀더 작은 발걸음으로 옮겨갈 것이다.  
가짜로 구현하기와 삼각측량의 어중간한 성질에 특별한 미덕이 있는 것은 아니다.  
뭘 타이핑해야 할지 알고, 그걸 재빨리 할 수 있다면 그냥 해버려라.  
‘제대로 동작하는’을 푸는 동시에 ‘깨끗한 코드’를 해결하려는 것은 한번에 하기에는 너무 많은 일일 수 있다.  
그렇게 되면 우선 ‘제대로 동작하는’으로 되돌아 가서 그걸 해결하고, 그 후에 ‘깨끗한 코드’를 느긋하게 해결하도록 하라.

## 하나에서 여럿으로
객체 컬렉션 collection 을 다루는 연산은 어떻게 구현하나? 일단은 컬렉션없이 구현하고 그 다음에 컬렉션을 사용하게 한다.
예를 들어 숫자 배열의 합을 구하는 함수를 작성한다고 가정하자. 일단 숫자 하나로 시작할 수 있다.
```JAVA
public void testSum() {
    assertEquals(5, sum(5));
}

private int sum(int value) {
    return value;
}
```
다음에는 sum(new int[] [5, 7])을 테스트 하고 싶다. 우선은 sum()에 배열을 받아들이는 인자를 하나 추가한다.

```JAVA
public void testSum() {
    assertEquals(5, sum(5, new int[]{5}));
}

private int sum(int value, int[] values) {
    return value;
}
```
우리는 이 단계를 변화 격리하기의 예로 볼수 있다.  
테스트 케이스에 인자를 추가하면 테스트 케이스에 영향을 주지 않으면서 자유로이 구현을 변경할 수 있다.  
이제 단일값 대신 컬렉션을 사용할 수 있다.

```JAVA
private int sum(int value, int[] values) {
    int sum = 0;
    for(int i=0;i<values.length;i++)
      sum += values[i];
    return sum;
}
```
다음에는 사용하지 않는 단일 인자를 삭제할 수 있다.
```JAVA
public void testSum() {
    assertEquals(5, sum(new int[]{5}));
}

private int sum(int[] values) {
    int sum = 0;
    for(int i=0;i<values.length;i++)
      sum += values[i];
    return sum;
}
```
직전 단계 역시 변화 격리하기의 예로, 코드를 고쳐서 테스트 케이스를 바꿔도 코드에 영향이 없도록 했다. 
```JAVA
public void testSum() {
    assertEquals(12, sum(new int[]{5, 7}));
}
```
