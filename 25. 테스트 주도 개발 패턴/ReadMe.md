# 25. 테스트 주도 개발 패턴

어떻게 테스트할 것인가에 대하여 말하기 전에 기본적인 전략에 관한 질문에 답해야 한다.
 - 테스트한다는 것은 무엇을 뜻하는가?
 - 테스트를 언제 해야 하는가?
 - 테스트할 로직을 어떻게 고를 것인가?
 - 테스트할 데이터를 어떻게 고를 것인가?

## 테스트(명사)
작성한 소프트웨어를 어떻게 테스트할 것인가? 자동화된 테스트를 만들어라  
테스트하다(test)는 '평가하다'라는 뜻의 동사이다. 보통은 아무리 작은 변화라도 테스트하지 않고 릴리즈하지는 않는다.  
테스트는 또한 '승인 또는 거부에 도달하는 과정'을 뜻하는 명사기도 하다. 어째서 명사로서의 테스트가 동사로서의 테스트와는 다른 느낌을 주는 걸까?  

![KakaoTalk_Photo_2022-07-05-21-40-50](https://user-images.githubusercontent.com/60125719/177329845-0f95fd04-e2ed-4f66-812c-782ea22b36f9.jpeg)
> 스타일의 영향도. 노드 사이의 화살표는 첫 번쨰 노드가 높아지면 두 번째 노드도 같이 높아진다는것을 의미하고, 동그라미가 그려진 화살표는 첫 번째 노드가 높아지면 반대로 두 번째 노드가 낮아진다는 뜻이다. 
  
-> 스트레스를 많이 받으면 테스트를 점점 더 뜸하게 한다. 테스트를 뜸하게 하면 에러는 점점 많아진다. 에러가 많아지면 스트레스를 더 받는다.  
어떻게 하면 이 고리에서 빠져나올 수 있을까? '테스트'를 '자동화된 테스트'로 치환해주자. "내가 이걸 고치면서 뭔가 다른 부분을 망가트리지 않았을까?"를 해결해준다.  

## 격리된 테스트

### 1. 테스트는 충분히 빨라서 내가 직접, 자주 실핼할 수 있게 만들어야한다.(그렇게 되면 내가 만든 에러를 다른 누구보다 먼저 내가 잡을 수 있다.)
### 2. 어마어마한 양의 오류가 반드시 어마어마한 양의 문제를 의미하는 것은 아니다.(앞 부분에서 실행된 테스트가 실패한 후 그 영향으로 다음 테스트부터는 엉망이 될 수 있다.)
이 문제를 해결하기 위해서는 **테스트를 실행하는 것은 서로 아무 영향이 없어야 한다.**
### 3. 테스트는 전체 애플리케이션을 대상으로 하는 것보다 좀더 작은 스케일로 하는 게 좋다.  
테스트를 격리하기 위한 작업은 결과적으로 시스템이 응집도는 높고 결합도는 낮은 객체의 모음으로 구성되도록 한다.  

## 테스트 목록
무엇을 테스트해야 할까?  
시작하기 전에 작성해야 할 테스트 목록을 모두 적어둘 것.  
**1. 프로그래밍 스트레스를 줄이기 위한 우리의 접근법의 첫 단계는 발 디딜 곳이 확실해지기 전엔 결코 발을 뗴어 전진하지 말자는 것.**  
##### 테스트를 한번에 전부 구현하는 방법이 왜 안좋은가?
 - 만들어진 모든 테스트는 리팩토링에 대해 약간의 관성을 갖는다. (먼저 다 만들면 나중에 무언가 바꿔야하는 상황이 왔을떄 열라 귀찮아서 안함)
 - 열 개의 테스트가 실패했다면 초록 막대를 보는 것은 한참 멀었다. 빨리 초록 막대를 볼 벙법은 열 개의 테스트를 모두 지우는것. 어느정도의 성취를 얻는것은 중요하지 ㅇㅇ;
  
  
테스트를 통과하게 만드는 과정에서 새로운 테스트가 필요한 것을 알게 될 것이다.  

## 테스트 우선
테스트는 테스트 대상이 되는 코드를 작성하기 직전에 작성하는것이 좋다. (코드를 만든 후에는 테스트를 안할꺼니)  
프로그래머로서 목표는 기능이 실행되도록 만드는것. 그리고 프로그램의 설계에 대해 생각해 볼 시간도 필요하고, 작업 범위를 조절할 방법도 필요하다.  
앞의 그림을 보면 위쪽에 있는 스트레스는 아래쪽에 있는 테스트와 음성적으로 연결되어있다.  
스트레스를 받을수록 테스트가 충분치 못해진다. 테스트를 충분히 하지 못했다고 생각하면 스트레스가 늘어난다.  
이 고리를 벗어나기위해 테스트를 먼저 해야 한다는 규칙을 도입해보자.  
테스트를 먼저 하면 스트레스가 줄고, 따라서 테스트를 더 많이 하게 된다.  


## 단언 우선
테스트를 작성할 때 단언(assert)은 언제쯤 쓸까? 단언을 제일 먼저 쓰고 시작하라. 
 - 시스템을 개발할 때 무슨 일부터 하는가? 완료된 시스템이 어떨 거라고 알려주는 이야기부터 작성한다. 
 - 특정 기능을 개발할 때 무슨 일부터 하는가? 기능이 완료되면 통과할 수 있는 테스트부터 작성한다.  
 - 테스트를 개발할 때 무슨 일부터 하는가? 완료될 떄 통과해야 할 단언부터 작성한다. 
  
단언을 먼저 작성하면 작업을 단순하게 만드는 강력한 효과를 볼 수 있다. 구현에 대해 전혀 고려하지 않고 테스트만 작성할 때도 사실 몇 가지 문제들을 한번에 해결하는것이다. 예를들면.. 
 - 테스트하고자 하는 기능이 어디에 속하는 걸까? 
 - 메서드 이름은 뭐라고 해야 하나?
 - 올바른 결과를 어떤 식으로 검사할 것인가?
 - 이 테스트가 제안하는 또 다른 테스트에는 뭐가 있을까?

### 올바른 결과는 무엇인가? 어떤 식으로 검사할 것인가?
ex) 소켓을 통해 다른 시스템과 통신한다고 하자. 통신을 마친 후 소켓은 닫혀 있고, 소켓에서 문자열 'abc'를 읽어와야 한다고 치자.

```Java
testCompleteTransaction() {
    ...
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```

reply는 어디에서 얻어오나? 물론 socket임

```Java
testCompleteTransaction() {
    ...
    Buffer reply = reader.contents();
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```

그럼 socket은 어디서 나오나? 서버에 접속할 때 생성된다.

```Java
testCompleteTransaction() {
    ...
    Socket reader = Socket("localhost", defaultPort());
    Buffer reply = reader.contents();
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```

물론 이 작업을 하기 전에 서버를 먼저 열어야 한다.

```Java
testCompleteTransaction() {
    Server writer = Server(defaultPort(), "abc");
    Socket reader = Socket("localhost", defaultPort());
    Buffer reply = reader.contents();
    assertTrue(reader.isClosed());
    assertEquals("abc", reply.contents());
}
```

## 테스트 데이터 

테스트 할 때 어떤 데이터를 사용해야 할까? 
 - 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하라. 테스트 작성에도 청중이 존재한다.  
 - 단지 데이터 값을 산발하기 위해 데이터 값을 산발하지 마라. 데이터 간에 차이가 있다면 그 속에 어떤 의미가 있어야 한다. 1과 2 사이에 어떠한 개념적 차이도 없다면 1을 사용하라.
 - 테스트 데이터 패턴의 한 가지 트릭은 여러 의미를 담는 동일한 상수를 쓰지 않는 것이다. 만약 plus() 메서드를 구현하려고 한다면 1 + 1이 아닌 3 + 4 같은 순서가 뒤집히면 다를 수 있는 데이터를 써야 한다는 것이다. 

테스트 데이터에 대한 대안은 실제 세상에서 얻어진 실제 데이터를 사용하는 것이다. 실제 데이터는 다음과 같은 경우에 유용하다. 
 - 실제 실행을 통해 수집한 외부 이벤트의 결과를 이용하여 실시간 시스템을 테스트하고자 하는 경우.
 - 예전 시스템의 출력과 현재 시스템의 출력을 비교하고자 하는 경우(병렬 테스팅)
 - 시뮬레이션 시스템을 리팩토링한 후 기존과 정확히 동일한 결과가 나오는지 확인하고자 할 경우. 특히 부동소수점 값의 정확성이 문제가 될 수 있다. 


## 명백한 데이터

데이터의 의도를 어떻게 표현할 것인가? 테스트 자체에 예상되는 값과 실제 값을 포함하고 이 둘 사이의 관계를 드러내기 위해 노력하라. 테스트를 작성할 때는 후에 코드를 읽을 다른 사람도 생각해야 한다.  
  
ex) 한 통화를 다른 통화로 환전하려고 하는데, 이 거래에는 1.5% 수수료가 붙는다. USD에서 GBP로 교환하는 환율이 2:1이라면 $100를 환전하려면 50GBP - 1.5% = 49.25GBP여야 한다.  
```Java
Bank bank = new Bank();
bank.addRate("USD", "GBP", STANDARD_RATE);
bank.commission(STANDARD_COMMISSION);
Money result = bank.convert(new Note(100, "USD"), "GBP");
assertEquals(new Note(49.25, "GBP"), result);
```

또는 계산을 더 명확히 표연할 수도 있다.
```Java
Bank bank = new Bank();
bank.addRate("USD", "GBP", 2);
bank.commission(0.015);
Money result = bank.convert(new Note(100, "USD"), "GBP");
assertEquals(new Note(100 / 2 * (1 - 0.015), "GBP"), result);
```
이 테스트에서는 입력으로 사용된 숫자와 예상되는 결과 사이의 관계를 읽어낼 수가 있다.
  
명백한 데이터가 주는 또 다른 이점은 프로그래밍이 더 쉬워진다는것.  
명백한 데이터는 코드에 매직넘버를 쓰지 말라는 것에 대한 예외적인 규칙일 수도 있다. 하지만 이미 정의된 기호 상수가 있다면 그걸 사용하자.
