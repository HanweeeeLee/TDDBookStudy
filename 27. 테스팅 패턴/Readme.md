# 27. 테스팅 패턴
이 패턴들은 더 상세한 테스트 작성법에 대한것이다.

## 자식 테스트
지나치게 큰 테스트 케이스를 어떻게 돌아가도록 할 수 있을까?  
원래 테스트 케이스의 깨지는 부분에 해당하는 작은 테스트 케이스를 작성하고 그 작은 테스트 케이스가 실행되도록 하라.  
그 후에 다시 원래의 큰 테스트 케이스를 추가하라.  
빨강/초록/리팩토링 리듬은 성공이 지속되는데 중요하기에 리듬을 유지하는것이 충분히 가치가 있다.  
작성한 테스트가 너무 크다면 거슬리는 테스트를 삭제하고 다시 시작한다.  
저자는 때로는 진짜로 테스트를 지워버리기도하고, 또는 메서드 이름 앞에 x를 추가해서 실행만되지 않게 하기도 한다고 말한다.  
두 가지 모두 시도해 보기를 권하는데, 테스트 두 개가 깨진 상황에서는 어떤 다른 느낌이 드는지, 스스로 어떤 다른 방식으로 코딩하는지 관찰해보고 적절한 방식을 선택해보도록 하자.

## 모의 객체(Mock Object)
비용이 많이 들거나 복잡한 리소스에 의존하는 객체를 테스트하려면, 상수를 반환하게끔 만든 속임수 버전의 리소스를 만들면 된다.  
모의 객체(Mock Object)에 대해서는 최소한 책 한 권 분량 정도의 자료가 있지만, 이 책에서는 간단한 소개 정도만 하고자 한다.  
고전적인 예는 데이터베이스 인데, 데이터베이스는 시작 시간이 오래 걸리고, 깨끗한 상태로 유지하기가 어렵다.  
그리고 만약 데이터베이스가 원격 서버에 있다면 이로 인해 테스트 성공 여부가 네트워크 상의 물리적 위치에 영향을 받게 되고 개발 중 많은 오류의 원인이 된다.  
해법은 대부분의 경우에 진짜 데이터베이스를 사용하지 않는 것이다.  
마치 데이터베이스인 것처럼 행동하지만 실제로는 메모리에만 존재하는 객체를 통해 작성될 수 있다.  
성능과 견고함에 더해 모의 객체의 또다른 가치는 가독성에 있다.  
모의 객체는 당신이 모든 객체의 가시성에 대해 고민하도록 격려해서, 설계에서 커플링이 감소하도록 한다.  
모의 객체를 사용하면 프로젝트에 위험 요소가 하나 추가 된다.  
모의 객체가 진짜 객체와 동일하게 동작하지 않으면 어떻게 될까?   
모의 객체용 테스트 집합을 진짜 객체가 사용 가능해질 때 그대로 적용해서 이러한 위험을 줄일 수 있다. 

## 셀프 션트 : 자기가 보낸 것이 다시 자신에게 제대로 돌아오는 지 확인하는 루프백 테스트와 유사하다.
한 객체가 다른 객체와 올바르게 대화하는지 테스트하려면 어떻게 할까?  
테스트 대상이 되는 객체가 원래의 대화 상대가 아니라 테스트 케이스와 대화하도록 만들면 된다.  
테스팅 사용자 인터페이스의 초록 막대를 동적으로 업데이트하고자하는 상황을 가정해 보자.  
UI 객체를 TestResult와 연결할 수 있다면 테스트가 실행된 시점, 테스트가 실패한 시점, 전체 테스트 슈트가 시작되고 끝난 시점 등을 통보 받을 수 있을 것이다.  
그리고 이를 위한 테스트는 다음과 같을 것이다. 

```python
//ResultListenerTest
def testNotification(self):
    result = TestResult()
    listener = ResultListener()
    result.addListener(listener)
    WasRun("testMethod").run(result)
    assert 1 == listener.count
```

이 테스트가 수행되려면 이벤트 통보 횟수를 셀 객체가 필요하다.

```python
//ResultListener
class ResultListener:
    def__init__(self):
        self.count= 0
    def startTest(self):
        self.count= self.count + 1
```

그런데 왜 이벤트 리스너를 위해 별도의 객체를 만들어야 하는 걸까? 그냥 테스트 케이스 자체를 리스너로 쓰면 될 텐데 말이다.  
즉 테스트 케이스가 일종의 모의 객체 노릇을 하는 것이다. 

```python
//ResultListenerTest
def testNotification(self):
    self.count = 0
    result= TestResult()
    result.addListener(self)
    WasRun("testMethod").run(result)
    assert 1 == self.count
def startTest(self):
    self.count= self.count + 1
```

셀프 션트 패턴을 이용해 작성한 테스트가 그렇지 않은 테스트보다 읽기에 더 수월하다. 위의 테스트가 좋은 예다.  
셀프 션트 패턴은 테스트 케이스가 구현할 인터페이스를 얻기 위해 인터페이스 추출(Extract Interface)을 해야 한다.  
(인터페이스를 추출하는 것이 더 쉬운지, 존재하는 클래스를 블랙 박스로 테스트하는 것이 더 쉬운지는 사용자의 몫이다)  
셀프션트를 위해 추출해 낸 인터페이스는 여러 곳에서 쓰이는 경우가 많다.  
파이썬과 같은 낙관적 타입 언어(동적인 타입 검사를 수행하는 언어)에서는 테스트 케이스 클래스가 실제로 테스트를 수행하는데 꼭 필요한 오퍼레이션들만 구현하면 된다.  
자바와 같은 비관적 타입 언어(정적인 타입 검사를 수행하는 언어)에서는 빈 메서드로라도 인터페이스의 모든 오퍼레이션들을 구현해야한다.  
인터페이스에 대한 구현은 또한 적절한 값을 되돌리거나 부적절한 오퍼레이션이 호출된 경우 예외를 던지게끔 만들어야 할 것이다.

## 로그 문자열
메시지의 호출 순서가 올바른지를 검사하려면 어떻게 해야 할까? 로그 문자열을 가지고 있다가 메시지가 호출될 때마다 그 문자열에 추가하도록 한다.  
로그 문자열은 특히 옵저버(Observer)를 구현하고, 이벤트 통보가 원하는 순서대로 발생하는지를 확인하고자 할 때 유용하다.  
만약 어떤 이벤트 통보들이 일어나는지를 검사하기는 하지만 그 순서는 상관이 없다면 문자열 집합을 저장하고 있다가 단언(assertion)에서 집합 비교를 수행하면 된다.  
로그 문자열은 셀프 션트와도 잘 작동한다. 해당 테스트 케이스는 로그를 추가하고 적절한 값을 반환하는 식으로 셀프 션트한 인터페이스의 메서드를 구현한다. 

## 크래시 테스트 더미
호출되지 않을 것 같은 에러 코드(발생하기 힘든 에러 상황)를 어떻게 테스트할 것인가?  
실제 작업을 수행하는 대신 그냥 예외를 발생시키기만 하는 특수한 객체를 만들어서 이를 호출한다.  
테스트 되지 않은 코드는 작동하는 것이 아닌것으로 간주하는 것이 가장 안전한 가정이며, 모든 부분을 테스트 할수 없으므로 작동하길 원하는 부분에 대해서만 하자.

## 깨진 테스트
혼자서 프로그래밍할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까? 마지막 테스트가 깨진 상태로 끝마치는 것이 좋다.  
나중에 다시 코딩하기 위해 돌아왔을 때, 어느 작업부터 시작할 것인지 명백히 알 수 있다. 전에 하고 있던 생각에 대한 명확하고 구체적인 책갈피를 가지게 되는 것이다.  
깨진 테스트가 하나가 있다고 해서 프로그램 완성도가 더 떨어지는 것은 아니며, 단지 프로그램의 상태를 드러나게 해줄 뿐이다.

## 깨끗한 체크인
팀 프로그래밍을 할 때 프로그래밍 세션을 어떤 상태로 끝마치는 게 좋을까? 모든 테스트가 성공한 상태로 끝마치는 것이 좋다.  
같은 팀원들과 함께 작업하는 경우라면 상황은 완전히 달라진다.  
프로젝트에서 프로그래밍 세션을 시작하는 경우라면 자신이 마지막으로 코딩한 다음부터 지금까지 무슨 일이 있었는지 세밀하게 알 수 없다.  
심이되고 확신이 서는 상태에서 시작할 필요가 있다. 따라서 코드를 체크인하기 전에 항상 모든 테스트가 돌아가는 상태로 만들어 두어야 한다.  
체크인하기 전에 실행하는 테스트 스위트(test suite)는 작업 중에 분 단위로 실행하는 테스트 슈트보다 더 클 것이다.  
때론 통합 테스트 슈트에서 테스트가 실패하는 경우도 있을 것이다. 그럴 땐 어떻게 해야 할까?  
가장 단순한 규칙은 그동안 작업한 코드를 날려버리고 다시 하는 것이다.  
실패한 테스트는 방금 여러분이 만들어 낸 프로그램을 여러분이 완전히 이해하지 못했음을 말해주는 강력한 증거다.  
만약 전체 팀원이 이 규칙을 따른다면 체크인을 더 자주하려는 경향이 생길 것이다. 왜냐하면 제일 먼저 체크인하는 사람은 작업을 날릴 위험이 없을 테니까. 
말할 필요도 없지만, 테스트 슈트를 통과시키기 위해 주석 처리 하는 것은 금지되는 것이다. 


